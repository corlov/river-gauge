+1) настроить на сервере прием данных по MQTT

+2) настроить перекладчик данных из MQTT в Influx на сервере

+3) попробовать залить данные (временными скриптами из старенького) и посомтреть как они попадут в InfluxDB

+4) средство отображения из InfluxDB (Graphana, etc)

  InfluxViewer:
      http://89.169.3.241:8086

5) научиться класть из устройств в Брокер

-------------------------------------------------------------------------------
Формат данных: protobuf

Технологии:
	MQTT
	InfluxDb
	для наполнения InfluxDb использовать telegraf


-------------------------------------------------------------------------------
Шаг 1: Определяем структуру данных (.proto файл)
Сначала на своем компьютере нужно создать файл, описывающий твои данные. Назовем его hydro_post.proto. Protobuf — это, по сути, контракт между отправителем и получателем.

// hydro_post.proto
syntax = "proto3";

message HydroPostData {
  uint32 station_id = 1;    // ID поста
  float water_level = 2;    // Уровень воды в метрах
  float temperature = 3;    // Температура воды
  uint64 timestamp = 4;     // Unix timestamp
}
Шаг 2: Генерируем код для микроконтроллера
Стандартные библиотеки Protobuf слишком тяжелые для ESP32. Поэтому мы будем использовать специальную, легковесную реализацию — nanopb.

Скачай nanopb на свой компьютер. Это просто набор скриптов.
Используй генератор из этого набора, чтобы превратить твой .proto файл в C-шные файлы (.c и .h), которые поймет Arduino.
Команда в терминале будет выглядеть примерно так:
python ./nanopb/generator/nanopb_generator.py hydro_post.proto
В результате ты получишь два файла: hydro_post.pb.c и hydro_post.pb.h.
Шаг 3: Пишем скетч для ESP32
Теперь самое интересное. В твоем проекте Arduino (или PlatformIO, что удобнее) тебе понадобятся:

Библиотека для MQTT. Самая популярная — PubSubClient.
Библиотека nanopb (ее можно найти в менеджере библиотек Arduino IDE).
Сгенерированные файлы hydro_post.pb.c и hydro_post.pb.h (их нужно положить прямо в папку с твоим скетчем .ino).





#include <WiFi.h>
#include <PubSubClient.h>

// Подключаем сгенерированные файлы и библиотеку nanopb
#include "pb_encode.h"
#include "hydro_post.pb.h" // Наш заголовочный файл

// --- Настройки сети и MQTT ---
const char* ssid = "YOUR_WIFI_SSID";
const char* password = "YOUR_WIFI_PASSWORD";
const char* mqtt_server = "YOUR_MQTT_BROKER_IP"; // IP твоего сервера
const int mqtt_port = 1883;
const char* mqtt_topic = "hydro/data";

WiFiClient espClient;
PubSubClient client(espClient);

void setup_wifi() {
  delay(10);
  Serial.println();
  Serial.print("Connecting to ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi connected");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());
}

void reconnect() {
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    if (client.connect("esp32-hydro-post")) { // ID клиента
      Serial.println("connected");
    } else {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" try again in 5 seconds");
      delay(5000);
    }
  }
}

void setup() {
  Serial.begin(115200);
  setup_wifi();
  client.setServer(mqtt_server, mqtt_port);
}

void loop() {
  if (!client.connected()) {
    reconnect();
  }
  client.loop();

  // --- Вот здесь вся магия Protobuf + MQTT ---

  // 1. Создаем структуру для наших данных
  HydroPostData message = HydroPostData_init_zero;

  // 2. Заполняем ее "боевыми" данными с датчиков
  message.station_id = 101;
  message.water_level = 1.23f; // f - значит float
  message.temperature = 15.7f;
  message.timestamp = 1677610200; // Здесь нужно получать реальное время

  // 3. Готовим буфер для сериализованных данных
  uint8_t buffer[128]; // Буфер с запасом
  pb_ostream_t stream = pb_ostream_from_buffer(buffer, sizeof(buffer));

  // 4. Кодируем (сериализуем) сообщение в бинарный формат
  bool status = pb_encode(&stream, HydroPostData_fields, &message);
  size_t message_length = stream.bytes_written;

  if (!status) {
    Serial.println("Encoding failed!");
    return;
  }

  // 5. Публикуем бинарные данные в MQTT топик
  Serial.print("Publishing message, size: ");
  Serial.println(message_length);

  // Важный момент: мы публикуем не строку, а массив байт (buffer)
  // с указанием его точной длины (message_length)
  client.publish(mqtt_topic, buffer, message_length);

  delay(60000); // Отправляем данные раз в минуту
}
